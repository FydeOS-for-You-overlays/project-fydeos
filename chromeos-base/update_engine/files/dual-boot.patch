diff --git a/boot_control_chromeos.cc b/boot_control_chromeos.cc
index e9ad698..ed2fcea 100644
--- a/boot_control_chromeos.cc
+++ b/boot_control_chromeos.cc
@@ -291,12 +291,34 @@ int BootControlChromeOS::GetPartitionNumber(
   // See http://www.chromium.org/chromium-os/chromiumos-design-docs/disk-format
   string partition_lower = base::ToLowerASCII(partition_name);
   int base_part_num = 2 + 2 * slot;
+  utils::DualBootPartitions dbp;
+  bool dualBoot = dbp.isDualBoot();
+  const int kernA_partition_number = dbp.getKernA();
+  const int kernB_partition_number = dbp.getKernB();
+  const int rootA_partition_number = dbp.getRootA();
+  const int rootB_partition_number = dbp.getRootB();
   if (partition_lower == kChromeOSPartitionNameKernel ||
-      partition_lower == kAndroidPartitionNameKernel)
-    return base_part_num + 0;
+      partition_lower == kAndroidPartitionNameKernel) {
+    if (dualBoot) {
+      LOG(INFO) << "FlintOS Dual boot \"" << dualBoot << "\"";
+      LOG(INFO) << "KernelA  Partition Number \"" << kernA_partition_number << "\"";
+      LOG(INFO) << "KernelB  Partition Number \"" << kernB_partition_number << "\"";
+      return (slot ? kernA_partition_number : kernB_partition_number);
+    }
+    else
+      return base_part_num + 0;
+  }   
   if (partition_lower == kChromeOSPartitionNameRoot ||
-      partition_lower == kAndroidPartitionNameRoot)
-    return base_part_num + 1;
+      partition_lower == kAndroidPartitionNameRoot) {
+    if (dualBoot) {
+      LOG(INFO) << "FlintOS Dual boot \"" << dualBoot << "\"";
+      LOG(INFO) << "RootA  Partition Number \"" << rootA_partition_number << "\"";
+      LOG(INFO) << "RootB  Partition Number \"" << rootB_partition_number << "\"";
+      return (slot ? rootA_partition_number : rootB_partition_number);
+    }
+    else
+      return base_part_num + 1;
+  }
   LOG(ERROR) << "Unknown Chrome OS partition name \"" << partition_name << "\"";
   return -1;
 }
diff --git a/common/utils.h b/common/utils.h
index d009fbb..617bda4 100644
--- a/common/utils.h
+++ b/common/utils.h
@@ -19,6 +19,8 @@
 
 #include <errno.h>
 #include <unistd.h>
+#include <fstream>
+#include <sstream>
 
 #include <algorithm>
 #include <map>
@@ -43,6 +45,107 @@ namespace chromeos_update_engine {
 
 namespace utils {
 
+// class for flintos dual boot feature
+class DualBootPartitions
+{
+  public:
+   DualBootPartitions() {
+    fillPartitionMap();
+   }
+
+   DualBootPartitions operator=(DualBootPartitions& ) =delete;
+   DualBootPartitions (DualBootPartitions& lhs)  =delete;
+
+   // dual boot or not ?
+   bool isDualBoot() {
+     return ((stoi(partitionMap.find(dualBoot_FlintOS)->second))? true : false);
+   }
+   // public methodds to get the respective partition numbers
+   int getKernA() {
+    if (partitionMap.find(dualBootKernA) != partitionMap.end())
+       return stoi(partitionMap.find(dualBootKernA)->second);
+    else
+     return 0;
+   }
+
+   int getKernB() {
+    if (partitionMap.find(dualBootKernB) != partitionMap.end())
+       return stoi(partitionMap.find(dualBootKernB)->second);
+    else
+     return 0;
+   }
+
+   int getKernC() {
+    if (partitionMap.find(dualBootKernC) != partitionMap.end())
+       return stoi(partitionMap.find(dualBootKernC)->second);
+    else
+     return 0;
+   }
+
+   int getRootA() {
+    if (partitionMap.find(dualBootRootA) != partitionMap.end())
+       return stoi(partitionMap.find(dualBootRootA)->second);
+    else
+     return 0;
+   }
+
+   int getRootB() {
+    if (partitionMap.find(dualBootRootB) != partitionMap.end())
+       return stoi(partitionMap.find(dualBootRootB)->second);
+    else
+     return 0;
+   }
+
+   int getRootC() {
+    if (partitionMap.find(dualBootRootC) != partitionMap.end())
+       return stoi(partitionMap.find(dualBootRootC)->second);
+    else
+     return 0;
+   }
+
+   int getEfiSystem() {
+    if (partitionMap.find(dualBootEfiSystem) != partitionMap.end())
+       return stoi(partitionMap.find(dualBootEfiSystem)->second);
+    else
+     return 0;
+   }
+  private: 
+   // map that holds the contents of the /etc/flintos-release
+   std::unordered_map <std::string, std::string> partitionMap;
+   // keys in the flintos-release for querying
+   std::string filename = "/etc/flintos-release";
+   std::string dualBoot_FlintOS = "FLINTOS_DUALBOOT";
+   std::string dualBootKernA = "DUALBOOT_KERN_A";
+   std::string dualBootKernB  = "DUALBOOT_KERN_B";
+   std::string dualBootKernC  = "DUALBOOT_KERN_C";
+   std::string dualBootRootA = "DUALBOOT_ROOT_A";
+   std::string dualBootRootB = "DUALBOOT_ROOT_B";
+   std::string dualBootRootC = "DUALBOOT_ROOT_C";
+   std::string dualBootEfiSystem = "DUALBOOT_EFI_SYSTEM";
+
+   void fillPartitionMap()
+   {
+     std::ifstream infile (filename.c_str());
+  
+     if (infile.is_open()) {
+         std::string line,key,value ;
+         while (getline(infile, line)) {
+             std::istringstream iss(line);
+             if (getline(iss, key, '=')) {
+                 if (getline(iss, value)) {
+                     partitionMap[key] = value;
+                 }
+             }
+         }
+         infile.close();
+      }
+      else {
+         //log error unable to open file
+          LOG(ERROR) << "/etc/flintos-release not readable or corrupt or file may be missing";
+      }
+    }
+};
+
 // Converts a struct timespec representing a number of seconds since
 // the Unix epoch to a base::Time. Sub-microsecond time is rounded
 // down.
